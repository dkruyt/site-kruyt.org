<!DOCTYPE html>
<html lang="en" dir="auto">

<head><meta charset="utf-8">
<meta http-equiv="X-UA-Compatible" content="IE=edge">
<meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">
<meta name="robots" content="index, follow">
<title>zswap metrics with Telegraf | Dennis Kruyt</title>
<meta name="keywords" content="grafana, telegraf, zswap, influxdb" />
<meta name="description" content="A couple of weeks ago I discover zswap.
 zswap is a Linux kernel feature that provides a compressed write-back cache for swapped pages, as a form of virtual memory compression. Instead of moving memory pages to a swap device when they are to be swapped out, zswap performs their compression and then stores them into a memory pool dynamically allocated in the system RAM. Later writeback to the actual swap device is deferred or even completely avoided, resulting in a significantly reduced I/O for Linux systems that require swapping; the tradeoff is the need for additional CPU cycles to perform the compression.">
<meta name="author" content="Dennis Kruyt">
<link rel="canonical" href="https://kruyt.org/post/2017/telegraf-zswap/" />
<link crossorigin="anonymous" href="/assets/css/stylesheet.min.c88963fe2d79462000fd0fb1b3737783c32855d340583e4523343f8735c787f0.css" integrity="sha256-yIlj/i15RiAA/Q&#43;xs3N3g8MoVdNAWD5FIzQ/hzXHh/A=" rel="preload stylesheet" as="style">
<script defer crossorigin="anonymous" src="/assets/js/highlight.min.7680afc38aa6b15ddf158a4f3780b7b1f7dde7e91d26f073e6229bb7a0793c92.js" integrity="sha256-doCvw4qmsV3fFYpPN4C3sffd5&#43;kdJvBz5iKbt6B5PJI="
    onload="hljs.initHighlightingOnLoad();"></script>
<link rel="icon" href="https://kruyt.org/favicon.ico">
<link rel="icon" type="image/png" sizes="16x16" href="https://kruyt.org/favicon-16x16.png">
<link rel="icon" type="image/png" sizes="32x32" href="https://kruyt.org/favicon-32x32.png">
<link rel="apple-touch-icon" href="https://kruyt.org/apple-touch-icon.png">
<link rel="mask-icon" href="https://kruyt.org/safari-pinned-tab.svg">
<meta name="theme-color" content="#2e2e33">
<meta name="msapplication-TileColor" content="#2e2e33">
<meta name="generator" content="Hugo 0.89.4" />
<noscript>
    <style>
        #theme-toggle,
        .top-link {
            display: none;
        }

    </style>
    <style>
        @media (prefers-color-scheme: dark) {
            :root {
                --theme: rgb(29, 30, 32);
                --entry: rgb(46, 46, 51);
                --primary: rgb(218, 218, 219);
                --secondary: rgb(155, 156, 157);
                --tertiary: rgb(65, 66, 68);
                --content: rgb(196, 196, 197);
                --hljs-bg: rgb(46, 46, 51);
                --code-bg: rgb(55, 56, 62);
                --border: rgb(51, 51, 51);
            }

            .list {
                background: var(--theme);
            }

            .list:not(.dark)::-webkit-scrollbar-track {
                background: 0 0;
            }

            .list:not(.dark)::-webkit-scrollbar-thumb {
                border-color: var(--theme);
            }
        }

    </style>
</noscript><meta property="og:title" content="zswap metrics with Telegraf" />
<meta property="og:description" content="A couple of weeks ago I discover zswap.
 zswap is a Linux kernel feature that provides a compressed write-back cache for swapped pages, as a form of virtual memory compression. Instead of moving memory pages to a swap device when they are to be swapped out, zswap performs their compression and then stores them into a memory pool dynamically allocated in the system RAM. Later writeback to the actual swap device is deferred or even completely avoided, resulting in a significantly reduced I/O for Linux systems that require swapping; the tradeoff is the need for additional CPU cycles to perform the compression." />
<meta property="og:type" content="article" />
<meta property="og:url" content="https://kruyt.org/post/2017/telegraf-zswap/" /><meta property="article:section" content="post" />
<meta property="article:published_time" content="2017-07-19T20:04:51&#43;00:00" />
<meta property="article:modified_time" content="2017-07-19T20:04:51&#43;00:00" />

<meta name="twitter:card" content="summary"/>
<meta name="twitter:title" content="zswap metrics with Telegraf"/>
<meta name="twitter:description" content="A couple of weeks ago I discover zswap.
 zswap is a Linux kernel feature that provides a compressed write-back cache for swapped pages, as a form of virtual memory compression. Instead of moving memory pages to a swap device when they are to be swapped out, zswap performs their compression and then stores them into a memory pool dynamically allocated in the system RAM. Later writeback to the actual swap device is deferred or even completely avoided, resulting in a significantly reduced I/O for Linux systems that require swapping; the tradeoff is the need for additional CPU cycles to perform the compression."/>


<script type="application/ld+json">
{
  "@context": "https://schema.org",
  "@type": "BreadcrumbList",
  "itemListElement": [
    {
      "@type": "ListItem",
      "position":  1 ,
      "name": "Posts",
      "item": "https://kruyt.org/post/"
    }, 
    {
      "@type": "ListItem",
      "position":  2 ,
      "name": "zswap metrics with Telegraf",
      "item": "https://kruyt.org/post/2017/telegraf-zswap/"
    }
  ]
}
</script>
<script type="application/ld+json">
{
  "@context": "https://schema.org",
  "@type": "BlogPosting",
  "headline": "zswap metrics with Telegraf",
  "name": "zswap metrics with Telegraf",
  "description": "A couple of weeks ago I discover zswap.\n zswap is a Linux kernel feature that provides a compressed write-back cache for swapped pages, as a form of virtual memory compression. Instead of moving memory pages to a swap device when they are to be swapped out, zswap performs their compression and then stores them into a memory pool dynamically allocated in the system RAM. Later writeback to the actual swap device is deferred or even completely avoided, resulting in a significantly reduced I/O for Linux systems that require swapping; the tradeoff is the need for additional CPU cycles to perform the compression.",
  "keywords": [
    "grafana", "telegraf", "zswap", "influxdb"
  ],
  "articleBody": "A couple of weeks ago I discover zswap.\n zswap is a Linux kernel feature that provides a compressed write-back cache for swapped pages, as a form of virtual memory compression. Instead of moving memory pages to a swap device when they are to be swapped out, zswap performs their compression and then stores them into a memory pool dynamically allocated in the system RAM. Later writeback to the actual swap device is deferred or even completely avoided, resulting in a significantly reduced I/O for Linux systems that require swapping; the tradeoff is the need for additional CPU cycles to perform the compression.\n How to activate zswap Active zswap runtime\necho 1  /sys/module/zswap/parameters/enabled or reboot persistent, add the following line to /etc/default/grub\nGRUB_CMDLINE_LINUX_DEFAULT=\"zswap.enabled=1\" With a system that is running pretty normal you won’t notice this effect right away. So we need some stats about zswap to see what it is doing. These stats about zswap are available in the kernel. You can find them in /sys/kernel/debug/zswap\n$:/sys/kernel/debug/zswap# grep . * duplicate_entry:0 pool_limit_hit:0 pool_total_size:256151552 reject_alloc_fail:0 reject_compress_poor:10925 reject_kmemcache_fail:0 reject_reclaim_fail:0 stored_pages:122760 written_back_pages:0 zswap statistics As I love stats, I want to add these to Grafana. Normaly I use Telegraf to collect statistics and insert them to InfluxDB. So I created a small plugin to collect these stats. All that is needed is on my GitHub page.\nGrafana screenshot zswap telegraf Install Telegraf plugin Download the swap.conf and swap.sh from my GitHub and place them in the telegraf.d dir.\n[[inputs.exec]] commands = [\"sudo /etc/telegraf/telegraf.d/zswap.sh\"] ## Timeout for each command to complete. timeout = \"5s\" # Data format to consume. # NOTE json only reads numerical measurements, strings and booleans are ignored. data_format = \"influx\" Make sure you put the next part in /etc/sudoers\ntelegraf ALL = NOPASSWD: /etc/telegraf/telegraf.d/zswap.sh When run with:\ntelegraf --test --config /etc/telegraf/telegraf.d/zswap.conf It should produce:\n* Plugin: inputs.exec, Collection 1  zswap,host=birdofprey pool_limit_hit=0,reject_kmemcache_fail=0,stored_pages=62742,written_back_pages=0,reject_reclaim_fail=0,duplicate_entry=0,pool_total_size=128495616,reject_alloc_fail=0,reject_compress_poor=2762 1498400744000000000 execute:\nservice telegraf restart After this it should log the statistics of zswap in InfluxDB. Now you can setup a dashboard for zswap in Grafana.\nMeasurements Measurement names:\n duplicate_entry pool_limit_hit pool_total_size reject_alloc_fail reject_compress_poor reject_kmemcache_fail reject_reclaim_fail stored_pages written_back_pages  Description pool_pages - number pages backing the compressed memory pool reject_compress_poor - reject pages due to poor compression policy (cumulative) (see max_compressed_page_size sysfs attribute) reject_zsmalloc_fail - rejected pages due to zsmalloc failure (cumulative) reject_kmemcache_fail - rejected pages due to kmem failure (cumulative) reject_tmppage_fail - rejected pages due to tmppage failure (cumulative) reject_flush_attempted - reject flush attempted (cumulative) reject_flush_fail - reject flush failed (cumulative) stored_pages - number of compressed pages stored in zswap outstanding_flushes - the number of pages queued to be written back flushed_pages - the number of pages written back from zswap to the swap device (cumulative) saved_by_flush - the number of stores that succeeded after an initial failure due to reclaim by flushing pages to the swap device pool_limit_hit - the zswap pool limit has been reached ",
  "wordCount" : "479",
  "inLanguage": "en",
  "datePublished": "2017-07-19T20:04:51Z",
  "dateModified": "2017-07-19T20:04:51Z",
  "author":{
    "@type": "Person",
    "name": "Dennis Kruyt"
  },
  "mainEntityOfPage": {
    "@type": "WebPage",
    "@id": "https://kruyt.org/post/2017/telegraf-zswap/"
  },
  "publisher": {
    "@type": "Organization",
    "name": "Dennis Kruyt",
    "logo": {
      "@type": "ImageObject",
      "url": "https://kruyt.org/favicon.ico"
    }
  }
}
</script>
</head>

<body class="" id="top">
<script>
    if (localStorage.getItem("pref-theme") === "dark") {
        document.body.classList.add('dark');
    } else if (localStorage.getItem("pref-theme") === "light") {
        document.body.classList.remove('dark')
    } else if (window.matchMedia('(prefers-color-scheme: dark)').matches) {
        document.body.classList.add('dark');
    }

</script>

<header class="header">
    <nav class="nav">
        <div class="logo">
            <a href="https://kruyt.org/" accesskey="h" title="Dennis Kruyt (Alt + H)">Dennis Kruyt</a>
            <span class="logo-switches">
                <button id="theme-toggle" accesskey="t" title="(Alt + T)">
                    <svg id="moon" xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24"
                        fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round"
                        stroke-linejoin="round">
                        <path d="M21 12.79A9 9 0 1 1 11.21 3 7 7 0 0 0 21 12.79z"></path>
                    </svg>
                    <svg id="sun" xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24"
                        fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round"
                        stroke-linejoin="round">
                        <circle cx="12" cy="12" r="5"></circle>
                        <line x1="12" y1="1" x2="12" y2="3"></line>
                        <line x1="12" y1="21" x2="12" y2="23"></line>
                        <line x1="4.22" y1="4.22" x2="5.64" y2="5.64"></line>
                        <line x1="18.36" y1="18.36" x2="19.78" y2="19.78"></line>
                        <line x1="1" y1="12" x2="3" y2="12"></line>
                        <line x1="21" y1="12" x2="23" y2="12"></line>
                        <line x1="4.22" y1="19.78" x2="5.64" y2="18.36"></line>
                        <line x1="18.36" y1="5.64" x2="19.78" y2="4.22"></line>
                    </svg>
                </button>
            </span>
        </div>
        <ul id="menu">
        </ul>
    </nav>
</header>
<main class="main">

<article class="post-single">
  <header class="post-header">
    
    <h1 class="post-title">
      zswap metrics with Telegraf
    </h1>
    <div class="post-meta"><span title='2017-07-19 20:04:51 +0000 UTC'>July 19, 2017</span>&nbsp;·&nbsp;Dennis Kruyt

</div>
  </header> 
  <div class="post-content"><p>A couple of weeks ago I discover <a href="https://en.wikipedia.org/wiki/Zswap">zswap</a>.</p>
<blockquote>
<p>zswap is a Linux kernel feature that provides a compressed write-back cache for swapped pages, as a form of virtual memory compression. Instead of moving memory pages to a swap device when they are to be swapped out, zswap performs their compression and then stores them into a memory pool dynamically allocated in the system RAM. Later writeback to the actual swap device is deferred or even completely avoided, resulting in a significantly reduced I/O for Linux systems that require swapping; the tradeoff is the need for additional CPU cycles to perform the compression.</p>
</blockquote>
<h3 id="how-to-activate-zswap">How to activate zswap<a hidden class="anchor" aria-hidden="true" href="#how-to-activate-zswap">#</a></h3>
<p>Active zswap runtime</p>
<pre tabindex="0"><code class="language-language-bash" data-lang="language-bash">echo 1 &gt; /sys/module/zswap/parameters/enabled
</code></pre><p>or reboot persistent, add the following line to <code>/etc/default/grub</code></p>
<pre tabindex="0"><code class="language-language-bash" data-lang="language-bash">GRUB_CMDLINE_LINUX_DEFAULT=&quot;zswap.enabled=1&quot;
</code></pre><p>With a system that is running pretty normal you won&rsquo;t notice this effect right away. So we need some stats about zswap to see what it is doing. These stats about zswap are available in the kernel. You can find them in <code>/sys/kernel/debug/zswap</code></p>
<pre tabindex="0"><code class="language-language-bash" data-lang="language-bash">$:/sys/kernel/debug/zswap# grep . *
duplicate_entry:0
pool_limit_hit:0
pool_total_size:256151552
reject_alloc_fail:0
reject_compress_poor:10925
reject_kmemcache_fail:0
reject_reclaim_fail:0
stored_pages:122760
written_back_pages:0 
</code></pre><h3 id="zswap-statistics">zswap statistics<a hidden class="anchor" aria-hidden="true" href="#zswap-statistics">#</a></h3>
<p>As I love stats, I want to add these to Grafana. Normaly I use Telegraf to collect statistics and insert them to InfluxDB. So I created a small plugin to collect these stats. All that is needed is on my <a href="https://github.com/dkruyt/telegraf-zswap">GitHub</a> page.</p>
<h5 id="grafana-screenshot-zswap-telegraf">Grafana screenshot zswap telegraf<a hidden class="anchor" aria-hidden="true" href="#grafana-screenshot-zswap-telegraf">#</a></h5>
<p><img loading="lazy" src="https://github.com/dkruyt/telegraf-zswap/raw/master/screenshot-grafana-zswap.jpg" alt="Grafana screenshot zswap"  />
</p>
<h4 id="install-telegraf-plugin">Install Telegraf plugin<a hidden class="anchor" aria-hidden="true" href="#install-telegraf-plugin">#</a></h4>
<p>Download the <a href="https://github.com/dkruyt/telegraf-zswap/blob/master/zswap.conf">swap.conf</a> and <a href="https://github.com/dkruyt/telegraf-zswap/blob/master/zswap.sh">swap.sh</a> from my <a href="https://github.com/dkruyt/telegraf-zswap">GitHub</a> and place them in the telegraf.d dir.</p>
<pre tabindex="0"><code>[[inputs.exec]]
  commands = [&quot;sudo /etc/telegraf/telegraf.d/zswap.sh&quot;]

  ## Timeout for each command to complete.
  timeout = &quot;5s&quot;

  # Data format to consume.
  # NOTE json only reads numerical measurements, strings and booleans are ignored.
  data_format = &quot;influx&quot;
</code></pre><p>Make sure you put the next part in <code>/etc/sudoers</code></p>
<pre tabindex="0"><code class="language-language-shell" data-lang="language-shell">telegraf ALL = NOPASSWD: /etc/telegraf/telegraf.d/zswap.sh
</code></pre><p>When run with:</p>
<pre tabindex="0"><code class="language-language-bash" data-lang="language-bash">telegraf --test --config /etc/telegraf/telegraf.d/zswap.conf
</code></pre><p>It should produce:</p>
<pre tabindex="0"><code class="language-language-bash" data-lang="language-bash">* Plugin: inputs.exec, Collection 1
&gt; zswap,host=birdofprey pool_limit_hit=0,reject_kmemcache_fail=0,stored_pages=62742,written_back_pages=0,reject_reclaim_fail=0,duplicate_entry=0,pool_total_size=128495616,reject_alloc_fail=0,reject_compress_poor=2762 1498400744000000000
</code></pre><p>execute:</p>
<pre tabindex="0"><code class="language-language-bash" data-lang="language-bash">service telegraf restart
</code></pre><p>After this it should log the statistics of zswap in InfluxDB. Now you can setup a dashboard for zswap in Grafana.</p>
<h4 id="measurements">Measurements<a hidden class="anchor" aria-hidden="true" href="#measurements">#</a></h4>
<p>Measurement names:</p>
<ul>
<li>duplicate_entry</li>
<li>pool_limit_hit</li>
<li>pool_total_size</li>
<li>reject_alloc_fail</li>
<li>reject_compress_poor</li>
<li>reject_kmemcache_fail</li>
<li>reject_reclaim_fail</li>
<li>stored_pages</li>
<li>written_back_pages</li>
</ul>
<h5 id="description">Description<a hidden class="anchor" aria-hidden="true" href="#description">#</a></h5>
<pre tabindex="0"><code>pool_pages - number pages backing the compressed memory pool
reject_compress_poor - reject pages due to poor compression policy (cumulative) (see max_compressed_page_size sysfs attribute)
reject_zsmalloc_fail - rejected pages due to zsmalloc failure (cumulative)
reject_kmemcache_fail - rejected pages due to kmem failure (cumulative)
reject_tmppage_fail - rejected pages due to tmppage failure (cumulative)
reject_flush_attempted - reject flush attempted (cumulative)
reject_flush_fail - reject flush failed (cumulative)
stored_pages - number of compressed pages stored in zswap
outstanding_flushes - the number of pages queued to be written back
flushed_pages - the number of pages written back from zswap to the swap device (cumulative)
saved_by_flush - the number of stores that succeeded after an initial failure due to reclaim by flushing pages to the swap device
pool_limit_hit - the zswap pool limit has been reached
</code></pre>

  </div>

  <footer class="post-footer">
    <ul class="post-tags">
      <li><a href="https://kruyt.org/tags/grafana/">grafana</a></li>
      <li><a href="https://kruyt.org/tags/telegraf/">telegraf</a></li>
      <li><a href="https://kruyt.org/tags/zswap/">zswap</a></li>
      <li><a href="https://kruyt.org/tags/influxdb/">influxdb</a></li>
    </ul>
  </footer>
</article>
    </main>
    
<footer class="footer">
    <span>&copy; 2021 <a href="https://kruyt.org/">Dennis Kruyt</a></span>
    <span>
        Powered by
        <a href="https://gohugo.io/" rel="noopener noreferrer" target="_blank">Hugo</a> &
        <a href="https://git.io/hugopapermod" rel="noopener" target="_blank">PaperMod</a>
    </span>
</footer>
<a href="#top" aria-label="go to top" title="Go to Top (Alt + G)" class="top-link" id="top-link" accesskey="g">
    <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 12 6" fill="currentColor">
        <path d="M12 6H0l6-6z" />
    </svg>
</a>

<script>
    let menu = document.getElementById('menu')
    if (menu) {
        menu.scrollLeft = localStorage.getItem("menu-scroll-position");
        menu.onscroll = function () {
            localStorage.setItem("menu-scroll-position", menu.scrollLeft);
        }
    }

    document.querySelectorAll('a[href^="#"]').forEach(anchor => {
        anchor.addEventListener("click", function (e) {
            e.preventDefault();
            var id = this.getAttribute("href").substr(1);
            if (!window.matchMedia('(prefers-reduced-motion: reduce)').matches) {
                document.querySelector(`[id='${decodeURIComponent(id)}']`).scrollIntoView({
                    behavior: "smooth"
                });
            } else {
                document.querySelector(`[id='${decodeURIComponent(id)}']`).scrollIntoView();
            }
            if (id === "top") {
                history.replaceState(null, null, " ");
            } else {
                history.pushState(null, null, `#${id}`);
            }
        });
    });

</script>
<script>
    var mybutton = document.getElementById("top-link");
    window.onscroll = function () {
        if (document.body.scrollTop > 800 || document.documentElement.scrollTop > 800) {
            mybutton.style.visibility = "visible";
            mybutton.style.opacity = "1";
        } else {
            mybutton.style.visibility = "hidden";
            mybutton.style.opacity = "0";
        }
    };

</script>
<script>
    document.getElementById("theme-toggle").addEventListener("click", () => {
        if (document.body.className.includes("dark")) {
            document.body.classList.remove('dark');
            localStorage.setItem("pref-theme", 'light');
        } else {
            document.body.classList.add('dark');
            localStorage.setItem("pref-theme", 'dark');
        }
    })

</script>
</body>

</html>
